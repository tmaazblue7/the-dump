diff --git a/src/forecasting.py b/src/forecasting.py
index 1111111..2222222 100644
--- a/src/forecasting.py
+++ b/src/forecasting.py
@@
-from prophet import Prophet
-import pandas as pd
-import logging
-
-logger = logging.getLogger(__name__)
-
-def forecast_membership(df: pd.DataFrame, periods: int = 12) -> pd.DataFrame:
-    """Forecast membership using Prophet.
-    
-    Args:
-        df: DataFrame with 'Date' and 'Membership_Count' columns
-        periods: Number of months to forecast
-        
-    Returns:
-        DataFrame with 'ds', 'yhat', 'yhat_lower', 'yhat_upper' columns
-    """
-    
-    # Validate required columns
-    required_cols = ['Date', 'Membership_Count']
-    missing_cols = [col for col in required_cols if col not in df.columns]
-    if missing_cols:
-        raise ValueError(f"Missing required columns: {missing_cols}")
-    
-    membership_df = df[['Date', 'Membership_Count']].dropna()
-    if membership_df.empty:
-        raise ValueError("No valid data for membership forecast after dropping NaN values")
-    
-    membership_df = membership_df.copy()
-    membership_df.columns = ['ds', 'y']
-    
-    model = Prophet(yearly_seasonality=True, daily_seasonality=False)
-    model.fit(membership_df)
-    future = model.make_future_dataframe(periods=periods, freq='MS')
-    forecast = model.predict(future)
-    
-    # Return only relevant columns
-    return forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]
-
-def forecast_call_volume(membership_forecast: pd.DataFrame, contact_rate: float) -> pd.DataFrame:
-    """Calculate monthly call volume based on membership forecast and contact rate.
-    
-    Args:
-        membership_forecast: DataFrame with 'yhat' column (annual membership)
-        contact_rate: Annual contact rate (0-1)
-        
-    Returns:
-        DataFrame with 'Monthly_Call_Volume' column added
-    """
-    if contact_rate < 0 or contact_rate > 1:
-        logger.warning(f"Contact rate {contact_rate} is outside 0-1 range")
-    
-    membership_forecast = membership_forecast.copy()
-    membership_forecast['Monthly_Call_Volume'] = (membership_forecast['yhat'] * contact_rate) / 12
-    
-    return membership_forecast
+from prophet import Prophet
+import pandas as pd
+import logging
+from typing import Optional
+
+logger = logging.getLogger(__name__)
+
+def forecast_membership(
+    df: pd.DataFrame,
+    periods: int = 12,
+    date_col: str = "Date",
+    value_col: str = "Membership_Count",
+    fallback_on_insufficient: bool = True,
+) -> pd.DataFrame:
+    """
+    Forecast membership as a monthly *stock* series using Prophet.
+
+    Steps:
+    - Validate schema and coerce types (date → datetime, value → numeric).
+    - Aggregate to month-start (unique `ds`) using the last observed value in each month.
+    - Require ≥ 2 observations; optionally fall back to a flat forecast if insufficient.
+    - Fit Prophet with monthly-appropriate settings (no weekly/daily seasonality, capped changepoints).
+
+    Returns a DataFrame with columns: ['ds', 'yhat', 'yhat_lower', 'yhat_upper'].
+    """
+    # 1) Validate required columns
+    missing = [c for c in (date_col, value_col) if c not in df.columns]
+    if missing:
+        raise ValueError(f"Missing required columns: {missing}")
+
+    data = df[[date_col, value_col]].copy()
+
+    # 2) Coerce numeric (strip non-numeric if object)
+    if data[value_col].dtype == object:
+        data[value_col] = (
+            data[value_col]
+            .astype(str)
+            .str.replace(r"[^0-9+\\-\\.]", "", regex=True)
+        )
+    data[value_col] = pd.to_numeric(data[value_col], errors="coerce")
+
+    # 3) Parse dates
+    data[date_col] = pd.to_datetime(data[date_col], errors="coerce")
+
+    # 4) Drop invalid rows
+    data = data.dropna(subset=[date_col, value_col]).copy()
+    if data.empty:
+        raise ValueError("No valid data for membership forecast after cleaning.")
+
+    # 5) Aggregate to monthly (MonthStart) to ensure unique ds
+    # Your CSVs use 1st-of-month dates, so align on MonthBegin for consistency.
+    mb = pd.offsets.MonthBegin(1)
+    monthly = (
+        data.sort_values(date_col)
+            .set_index(date_col)[[value_col]]
+            .resample(mb).last()
+            .dropna()
+            .rename(columns={value_col: "y"})
+    )
+    monthly.index.name = "ds"
+    history = monthly.reset_index()[["ds", "y"]]
+
+    # 6) Validate sufficient history
+    if len(history) < 2:
+        msg = (
+            f"Insufficient membership history after monthly aggregation: {len(history)} rows. "
+            f"Ensure you're passing historical rows with '{value_col}' populated "
+            "(not just future rows that only have 'Forecasted_Membership')."
+        )
+        if fallback_on_insufficient:
+            logger.warning("%s Falling back to a flat forecast.", msg)
+            last_ds = history["ds"].max() if len(history) else pd.Timestamp.today().normalize()
+            last_y = float(history["y"].iloc[-1]) if len(history) else 0.0
+            future_ds = pd.date_range(last_ds, periods=periods, freq=mb, inclusive="right")
+            out = pd.DataFrame({
+                "ds": future_ds,
+                "yhat": [last_y] * periods,
+                "yhat_lower": [last_y] * periods,
+                "yhat_upper": [last_y] * periods,
+            })
+            return out
+        else:
+            raise ValueError(msg)
+
+    # 7) Fit Prophet (monthly → disable weekly/daily; cap changepoints for short series)
+    n_cp = max(0, min(10, len(history) - 2))
+    model = Prophet(
+        yearly_seasonality=True,
+        weekly_seasonality=False,
+        daily_seasonality=False,
+        n_changepoints=n_cp,
+        growth="linear",
+    )
+    # Quiet chatty libs
+    logging.getLogger("prophet").setLevel(logging.WARNING)
+    logging.getLogger("cmdstanpy").setLevel(logging.WARNING)
+
+    model.fit(history)
+    future = model.make_future_dataframe(periods=periods, freq=mb, include_history=False)
+    forecast = model.predict(future)
+    return forecast[["ds", "yhat", "yhat_lower", "yhat_upper"]].copy()
+
+def forecast_call_volume(membership_forecast: pd.DataFrame, annual_contact_rate: float) -> pd.DataFrame:
+    """
+    Calculate **monthly** call volume from a **monthly stock** membership forecast
+    and an **annual per-member** contact rate (0–1, inclusive).
+
+    If your rate is already monthly, pass the monthly rate and remove the divide-by-12.
+    """
+    if annual_contact_rate < 0 or annual_contact_rate > 1:
+        logger.warning("Contact rate %.4f is outside 0–1.", annual_contact_rate)
+    out = membership_forecast.copy()
+    out["Monthly_Call_Volume"] = (out["yhat"] * annual_contact_rate) / 12.0
+    return out