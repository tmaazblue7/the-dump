diff --git a/src/forecasting.py b/src/forecasting.py
index 0000000..1111111 100644
--- a/src/forecasting.py
+++ b/src/forecasting.py
@@
+import logging
+from typing import Optional, Tuple, List
+import pandas as pd
+from prophet import Prophet
+
+_LOG = logging.getLogger(__name__)
+
+def _infer_columns(df: pd.DataFrame) -> Tuple[Optional[str], Optional[str]]:
+    """Heuristically pick (date_col, value_col) for membership from lob_df."""
+    # Date candidates
+    date_candidates = ["ds", "date", "Date", "month", "Month", "period", "Period"]
+    date_col = next((c for c in date_candidates if c in df.columns), None)
+    # Value candidates (membership stock)
+    value_candidates = [
+        "membership", "Membership",
+        "members", "Members",
+        "total_members", "Total_Members", "TotalMembers",
+        "enrollment", "Enrollment",
+        "member_count", "Member_Count",
+    ]
+    value_col = next((c for c in value_candidates if c in df.columns), None)
+    return date_col, value_col
+
+def _prepare_membership_df(lob_df: pd.DataFrame,
+                           date_col: Optional[str],
+                           value_col: Optional[str]) -> pd.DataFrame:
+    """
+    Build a Prophet-ready dataframe with columns ds (datetime) and y (float).
+    - Parses dates robustly
+    - Coerces membership to numeric
+    - Drops NaNs
+    - Aggregates to month-end (stock series â†’ use last observed in month)
+    """
+    if date_col is None or value_col is None:
+        raise ValueError(
+            "Could not infer date/value columns for membership. "
+            "Expected something like Date/Month and Membership/Members."
+        )
+    df = lob_df[[date_col, value_col]].copy()
+    # Parse date and numeric value
+    df[date_col] = pd.to_datetime(df[date_col], errors="coerce")
+    df[value_col] = pd.to_numeric(df[value_col], errors="coerce")
+    # Drop rows with invalid date or value
+    df = df.dropna(subset=[date_col, value_col]).copy()
+    if df.empty:
+        return pd.DataFrame(columns=["ds", "y"])
+    # Sort and set index for resample
+    df = df.sort_values(date_col)
+    df = df.set_index(date_col)
+    # Monthly stock: take last value in each month
+    monthly = df[[value_col]].resample("M").last()
+    monthly = monthly.dropna(subset=[value_col]).copy()
+    monthly = monthly.rename(columns={value_col: "y"})
+    monthly.index.name = "ds"
+    monthly = monthly.reset_index()
+    # De-duplicate ds just in case
+    monthly = monthly.drop_duplicates(subset=["ds"], keep="last")
+    return monthly[["ds", "y"]]
+
+def _fit_prophet_membership(history: pd.DataFrame) -> Prophet:
+    """Create and fit a Prophet model suitable for monthly membership."""
+    n_obs = len(history)
+    # Cap changepoints to something sensible for short histories
+    n_cp = max(0, min(10, n_obs - 2))
+    m = Prophet(
+        yearly_seasonality=True,
+        weekly_seasonality=False,
+        daily_seasonality=False,
+        n_changepoints=n_cp,
+        growth="linear",
+    )
+    # Quiet noisy libs
+    logging.getLogger("prophet").setLevel(logging.WARNING)
+    logging.getLogger("cmdstanpy").setLevel(logging.WARNING)
+    m.fit(history.rename(columns={"ds": "ds", "y": "y"}))
+    return m
+
+def _naive_flat_forecast(history: pd.DataFrame, periods: int) -> pd.DataFrame:
+    """Fallback: extend the last observed y forward as a flat forecast."""
+    if history.empty:
+        return pd.DataFrame(columns=["ds", "yhat", "yhat_lower", "yhat_upper"])
+    last_ds = history["ds"].max()
+    last_y = float(history.loc[history["ds"].idxmax(), "y"])
+    future_ds = pd.date_range(last_ds, periods=periods+1, freq="M", inclusive="right")
+    out = pd.DataFrame({
+        "ds": future_ds,
+        "yhat": [last_y] * periods,
+        "yhat_lower": [last_y] * periods,
+        "yhat_upper": [last_y] * periods,
+    })
+    return out
+
+def forecast_membership(lob_df: pd.DataFrame,
+                        periods: int,
+                        date_col: Optional[str] = None,
+                        value_col: Optional[str] = None,
+                        fallback_on_insufficient: bool = True) -> pd.DataFrame:
+    """
+    Forecast membership using Prophet on monthly stock values.
+    - Auto-detects columns if not provided.
+    - Cleans and validates data before fitting.
+    - If < 2 observations remain, emits a WARNING and (by default) returns a
+      naive flat forecast to avoid crashing downstream.
+    """
+    if date_col is None or value_col is None:
+        inferred_date, inferred_val = _infer_columns(lob_df)
+        date_col = date_col or inferred_date
+        value_col = value_col or inferred_val
+        _LOG.info("forecast_membership: using columns date=%r value=%r", date_col, value_col)
+
+    history = _prepare_membership_df(lob_df, date_col, value_col)
+
+    # Validate sufficient data
+    valid_rows = int(history["y"].notna().sum()) if not history.empty else 0
+    if valid_rows < 2:
+        msg = (f"Insufficient membership history after cleaning: {valid_rows} valid rows. "
+               f"date_col={date_col!r}, value_col={value_col!r}. "
+               "Check input data or column names.")
+        if fallback_on_insufficient:
+            _LOG.warning("%s Falling back to naive flat forecast.", msg)
+            return _naive_flat_forecast(history, periods)
+        else:
+            raise ValueError(msg)
+
+    # Fit Prophet and make future monthly forecast
+    model = _fit_prophet_membership(history)
+    future = model.make_future_dataframe(periods=periods, freq="M", include_history=False)
+    forecast = model.predict(future)
+    return forecast[["ds", "yhat", "yhat_lower", "yhat_upper"]].copy()